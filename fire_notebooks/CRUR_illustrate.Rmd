---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: fire
    language: python
    name: fire
---

###  Illustrative notebook showing a single parameter case

```{python}
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import sys
import time
import itertools
import multiprocessing as mp
import copy
import math
from statsmodels.graphics.tsaplots import plot_acf

sys.path.append("/Users/octavia/Dropbox/fire/src" )

mymodules = ['plot_config', "fire_model", "fire_plot", "fire_analytic" ]

for mod in mymodules:
    if mod in sys.modules:
        del sys.modules[mod]


from plot_config import *
from fire_model import *
from fire_analytic import *
from fire_plot import *
```

```{python}
# A simple example 
p = RCSR()
update = {"alpha" : 0.02,
          "beta" : 0,
          "G_lo" : p.k_l/100., 
          "soil_feedback" : "C",          
          "ti" : 0, 
          "tmax" : 100,
          "RI" : 101,
          "severity" : 0.5,
          "dt" : 0.01,
          "dt_p" : 0.1
         }
p = RCSR(update)

p.run()

fig, ax = plt.subplots(1, figsize = (14,4) )

ax.plot(p.t_p, p.G_u_list, '-', label ="upper canopy")        
ax.plot(p.t_p, p.G_l_list, label = "lower canopy")       
ax.set_ylabel("biomass")
ax.legend()

G_ua = p.G_u_analytic(p.t_p)    
ax.plot(p.t_p, G_ua, '--')

G_umean = p.integrate_G_u_analytic( p.G_uo, p.tmax, 0)
print("Mean analytic G_u {0:.2f}".format(G_umean) )
print("Mean G_u {0:.2f}".format(np.mean(p.G_u_list)) )

```

```{python}
# This code block is meant to show that we can predict the max severity and 
# min frequency to sustain biomass in the upper canopy

p = RCSR()
update = {"soil_feedback" : "C",
          "r_l" : 0.5,          
          "alpha" : 0.1,
          "beta" : 0,
          "G_u" : p.k_u/10.,
          "G_l" : p.k_l/10., 
          "ti" : 2000, 
          "tmax" : 1000,
          "RI" : 60,
          "severity" : 0.7,
          "dt" : 0.01,
          "dt_p" : 0.1,

         }


p = RCSR(update)
p.run()

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}
p.record["error"] = (p.mean_G_u()- p.record.G_u_mean)/p.mean_G_u()*100
p.record.tail()
```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', c = 'k')


```

```{python}

## Plot the analytical solution

# (1) plot the analytical solution after any given fire 
# (2) check the analytical predictions of minimum and maximum G_u
# (3) check the approximation of minimum G_l.  Move on to analytic expression for G_l later

RI = 20
severity = 0.5
update = {
          "alpha" : 0.1,
          "r_l" : 2,
          "beta" : 0,
          "ti" : 2000, 
          "RI" : RI,
          "tmax" : 3*RI,
          "severity" : severity,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }
                
p = RCSR(update)
p.run()

fig, ax = plt.subplots(1, figsize = (14,4) )


ax.plot(p.t_p, p.G_u_list, '-', label ="upper canopy")        
ax.plot(p.t_p, p.G_l_list, label = "lower canopy")       
plot_G_l_a(p,ax)   
plot_G_u_a(p,ax)   
ax.legend()
ax.set_ylabel("biomass")    
plot_fire_events(p, ax)

```

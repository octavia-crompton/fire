---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: fire
    language: python
    name: fire
---

```{python}
# %autosave 0
```

Explore sensitivity to varying soil moisture, growth-limiting factor, etc.

```{python}
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import sys
import time
import itertools
import multiprocessing as mp
import copy
import math
from statsmodels.graphics.tsaplots import plot_acf

sys.path.append("/Users/octavia/Dropbox/fire/src_v1" )

mymodules = ['plot_config', "fire_model", "fire_plot", "fire_analytic" ]

for mod in mymodules:
    if mod in sys.modules:
        del sys.modules[mod]


from plot_config import *
from fire_model import *
from fire_analytic import *
from fire_plot import *
```

```{python}
RI = 10
phi_S = 0.91
```

```{python}
update = {"soil_feedback" : "C",
          "r_l" : 1.5,          
          "alpha" : 0.04,
          "beta" : 0.5,
          "ti" : 1000, 
          "tmax" : 1000,
          "RI" : 20,
          "severity" : 0.7,
          "dt" : 0.01,
          "dt_p" : 0.1,
          "seed" : 0,
          "S" : 0.5
         }
```

```{python}
# This code block is meant to show that we can predict the max severity and 
# min frequency to sustain biomass in the upper canopy


p = RCSR()
p = RCSR(update)
p.run()

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}
p.record["error"] = (p.mean_G_u()- p.record.G_u_mean)/p.mean_G_u()*100
p.record.tail()
```

```{python}
canopy_plot(p, nfire = 5)
```

```{python}
fig, axes = plt.subplots(1, 2, figsize = (13, 4))

r_u = 0.25
r_l = 2
k_l = 5
k_u = 20
beta = 0.5
RI = 20
severity = 0.6
alpha = 0.05
S = np.arange(0.01, 1, .001)

for beta in np.arange(0.1, 1.1, 0.3):
    beta = np.round(beta, 1)
    
    ax = axes[0]
    
    G_u_mean = mean_G_u(r_u ,  k_u , S, beta , RI , severity)
    ax.plot(S,G_u_mean, label = beta)
    
    ax = axes[1]
    
    G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )
    G_l_mean[G_l_mean == 0] = np.nan
    ax.plot(S,G_l_mean, label = beta)

axes[0].legend(title =r"$\beta$")
axes[1].legend(title =r"$\beta$")
axes[0].set_xlabel("S")
axes[0].set_ylabel("$G_u$")
axes[1].set_ylabel("$G_l$")

```

```{python}
fig, axes = plt.subplots(1, 2, figsize = (13, 4))

r_u = 0.25
r_l = 2
k_l = 5
k_u = 20
RI = 20
severity = 0.8
alpha = 0.05
S = np.arange(0.01, 1, .001)

    
ax = axes[0]
beta = np.round(0.5, 1)
G_u_mean = mean_G_u(r_u ,  k_u , S, beta , RI , severity)
ax.plot(S,G_u_mean, label = beta)

G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )
G_l_mean[G_l_mean == 0] = np.nan
ax.plot(S,G_l_mean)
ax.axvline(S[G_u_mean>0][0], c = "k")

ax = axes[1]

beta = np.round(1, 1)
G_u_mean = mean_G_u(r_u ,  k_u , S, beta , RI , severity)
ax.plot(S,G_u_mean, label = beta)

G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )
G_l_mean[G_l_mean == 0] = np.nan
ax.plot(S,G_l_mean, label = beta)
ax.axvline(S[G_u_mean>0][0], c = "k")

axes[0].legend(title =r"$\beta$")
axes[1].legend(title =r"$\beta$")
axes[0].set_xlabel("S")
axes[0].set_ylabel("$G_u$")
axes[1].set_ylabel("$G_l$")

```

```{python}

def f_r_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity ):
    """
    Computes the modified lower canopy growth rate as:

        r_lp = r_l*S^beta - alpha*G_u_mean
    """ 
    r_up = r_u*S**beta

    G_u_mean = greater_than_zero(k_u*(1+np.log(1-severity)/(r_up*RI)))

    r_lp = r_l*S**beta-alpha*G_u_mean

    return r_lp

def f_k_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity ):
    """
    Computes the modified lower canopy carrying capacity as:

        k_lp  = k_l r_lp / (r_l S**beta)

    """ 

    r_lp = f_r_lp(r_l, r_u, k_l, k_u, S, beta, alpha, RI, severity )

    return k_l*r_lp/(r_l*S**beta)


```

```{python}
fig, axes = plt.subplots(1, 2, figsize = (12, 4))

r_u = 0.25
r_l = 2
k_l = 5
k_u = 20
beta = 1
RI = 15
severity = 0.6
alpha = 0.06
S = np.arange(0.01, 1, .001)

for beta in [0.8]:
    beta = np.round(beta, 1)
    
    ax = axes[0]
    G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )
    r_lp =  f_r_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity)    
    k_lp =  f_k_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity)        
    G_l_mean[G_l_mean == 0] = np.nan
    ax.plot(S,G_l_mean, label = r"$\hat G_l$")
    ax.plot(S,r_lp*5, label = "$r'_l$", ls =  '--')    
    ax.plot(S,k_lp, label = "$k'_l$", ls =  '--')        

    
    ax = axes[1]
    G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )
    r_lp =  f_r_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity)    
    k_lp =  f_k_lp(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity)        
    G_l_mean[G_l_mean == 0] = np.nan
    G_u_mean = mean_G_u(r_u , k_u , S, beta , RI , severity)
    
    ax.plot(S,G_l_mean, label = r"$\hat G_l$")

    ax.plot(S,alpha*G_l_mean*G_u_mean,
            label = r"$\alpha \hat G_l \hat G_u$")

    ax.plot(S,r_l*S**beta*G_l_mean*(1- G_l_mean/k_l),
            label = r"$r_l \hat G_l (1 - \hat G_l / k_l) $")    
    
    ax.axvline(S[G_u_mean>0][0], c = "k", lw = 0.5)    
    
axes[0].legend()
leg = axes[1].legend()
ax.legend(loc='center left', bbox_to_anchor=(0.99, 0.5))

axes[0].set_xlabel("S")
axes[0].set_ylabel("$G_l$")
# ax.set_ylim(0,5)
```

```{python}
def S_loc_G_l_min(r_u,  k_u, S, beta, alpha, RI, severity):
    """
    Find the soil moisture content where the lower canopy has a minimum value
    """
    Z = np.log(1-severity)/RI
    th = (-alpha*k_u*2*Z/(alpha*k_u*r_u - r_u*Z))**(1/beta) 
    return th
# We could figure out, for a given beta, the range of soil moisture values for which the lower canopy will
# be unstable
```

```{python}
def dG_dS( r,  k, S, beta, RI, severity):
    """
    Applicable for G_u, 
    or for G_l when G_u -> 0 
    """
    return - beta*k*S**(-1. -beta)*np.log(1-severity)/RI/r
    
```

```{python}
def dG_l_dS(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity):
    
    Z = np.log(1-severity)/RI
    
    a = (beta*k_l*S**(-1 - 2*beta))/(r_l*r_u)
    b = (-(r_u*S**beta*Z) + alpha*k_u*(r_u*S**beta + 2*Z))
    
    return a*b

```

```{python}
S = np.arange(0.05, 0.5, .0001)

for beta in [1]:
    
    # soil moisture for which G_u --> 0
    S_u_min = (-np.log(1-severity)/RI/r_u)**(1/beta)
    
    # soil moisture location of the minimum G_l
#     S_l_min = S_l_min_G_l_min(r_u,  k_u, S, beta, alpha, RI, severity)

    # compute the lower canopy derivative
    deriv = dG_l_dS(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity)
    deriv_no_canopy = dG_dS( r_l,  k_l, S, beta, RI, severity)
    deriv[S <= S_u_min] = deriv_no_canopy[S <= S_u_min]

    plt.plot(S, deriv, label = beta, ls =  '-')
    
    plt.axvline(S_u_min, c = "k", ls = "-.", lw = 0.75 )

    
    # mean G_l
    G_l_mean =   mean_G_l(r_l, r_u, k_l, k_u, S , beta, alpha , RI , severity )

    # numerical
    deriv_num = np.diff(G_l_mean)/np.diff(S)[0]
    deriv_num =  np.insert(deriv_num,0,0)
    plt.plot(S,deriv_num, label = beta, ls =  "-.")
    

plt.axhline(0)
```

## To be really lazy about things, say increasing soil moisture *decreases* the probability of ignition as 
$$  p = \frac{1}{RI}(1-S)$$

```{python}
fig, axes = plt.subplots(1, 2, figsize = (13, 4))


S = np.arange(0.1, 1, .001)
for beta in np.arange(0.1, 1.1, 0.3):
    beta = np.round(beta, 1)
    
    ax = axes[0]
    
    G_u_mean = mean_G_u(r_u = 0.25,  k_u = 20, S =S, beta = beta, RI =  20/(1- S), severity = 0.6)
    ax.plot(S,G_u_mean, label = beta)
    
    ax = axes[1]

    
    G_l_mean =   mean_G_l(r_l = 1.5, r_u = 0.25, k_l = 5, k_u = 20, S =S, beta = beta, alpha = 0.05, RI = 20/(1- S), severity = 0.6)
    G_l_mean[G_l_mean == 0] = np.nan
    ax.plot(S,G_l_mean, label = beta)

axes[0].legend(title =r"$\beta$")
axes[1].legend(title =r"$\beta$")
axes[0].set_xlabel("S")
axes[0].set_ylabel("$G_u$")
axes[1].set_ylabel("$G_l$")

```

##  say increasing soil moisture *decreases* the probability of ignition as 
$$  p = \frac{1}{S \cdot RI}$$

```{python}

fig, axes = plt.subplots(1, 2, figsize = (13, 4))


S = np.arange(0.1, 1, .001)
for beta in np.arange(0.1, 1.1, 0.3):
    beta = np.round(beta, 1)
    
    ax = axes[0]
    
    G_u_mean = mean_G_u(r_u = 0.25,  k_u = 20, S =S, beta = beta, RI =  20*S, severity = 0.6)
    ax.plot(S,G_u_mean, label = beta)
    
    ax = axes[1]

    
    G_l_mean =   mean_G_l(r_l = 1.5, r_u = 0.25, k_l = 5, k_u = 20, S =S, beta = beta,
                          alpha = 0.05, RI = 20*S, severity = 0.6)
    G_l_mean[G_l_mean == 0] = np.nan
    ax.plot(S,G_l_mean, label = beta)

axes[0].legend(title =r"$\beta$")
axes[1].legend(title =r"$\beta$")
axes[0].set_xlabel("S")
axes[0].set_ylabel("$G_u$")
axes[1].set_ylabel("$G_l$")

```

```{python}
# This code block is meant to show that we can predict the max severity and 
# min frequency to sustain biomass in the upper canopy


p = RCSR()


update .update({
          "severity_type" : "random",
          "ignition_type" : "random",          
          "sigma_phi" : 0.01,
          "tmax" : 2000,
          "seed" :0
         })


p = RCSR(update)
p.run()


```

```{python}
canopy_plot(p)
```

```{python}

```

```{python}
G_u_mean_list = np.cumsum(p.G_u_list)/(np.arange(len(p.G_u_list)))
G_l_mean_list = np.cumsum(p.G_l_list)/(np.arange(len(p.G_u_list)))
```

```{python}
plt.plot(p.t_p[:], G_l_mean_list[:])
plt.axhline(p.mean_G_l(), ls=  '--')
```

```{python}
plt.plot(p.t_p[:], G_u_mean_list[:])
plt.axhline(p.mean_G_u(), ls=  '--')
```

```{python}

```

---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: fire3
    language: python
    name: fire3
---

```{python}
# %autosave 0
```

```{python}
import os
startup_file = "/Users/octavia/Dropbox/fire/src_v1/startup.py"
```

```{python}
run "/Users/octavia/Dropbox/fire/src_v1/startup.py"
```

###  Maximum severity / minimm return interval to sustain upper canopy biomass

```{python}
params =  {
    "alpha" : 0.04,
    "beta" : 0.5,
    "k_u" : 20.,
    "k_l" : 5.,    
    "r_u" : 0.25,
    "r_l" : 1.5,                    
    "S" : 0.5,
    "dt" : 0.01,
    "dt_p" : 0.1,            
    "seed" : 0,
    "ti" : 1000,        
    "tmax" : 3000,      
    "RI" : 20,
    "ignition_type" : "fixed",   
    "chi" : 1,                           
    "severity_type" : "fixed",
    "severity" : 0.7,
    "std_severity" : 0.1,
    "r" : 0.5, 
    "a" : 0.01,
    "b" : 0.99
} 
p = RCSR(params)
```

```{python}

fig, ax = plt.subplots(1, figsize = (7,3.5) )

RIs = np.arange(0, 100, .1)
severities = max_severity_u(p.r_u*p.S**p.beta, RIs)
ax.plot(  RIs,severities )
ax.fill_between(RIs,severities, alpha = 0.1)

for gamma in [0.1, 0.5, 0.75, 0.9]:
    severities = max_severity_u((1-gamma)*p.r_u*p.S**p.beta, RIs)
    ax.plot(RIs, severities , '--', label = gamma)


ax.legend(title = "$\gamma$")
ax.set_ylabel("maximum severity")
ax.set_xlabel("Return interval (years)")
ax.set_title("Stability curve ($\hat G_u = \gamma k_u$)")
fig.savefig(figdir + '/stability.png', format='png', dpi=1000, bbox_inches = "tight")

```

## Double check the stability curve

```{python}
gamma = 0.5
p = RCSR(params)
severity = max_severity_u((1-gamma)*p.r_u*p.S**p.beta, p.RI)
params["severity"] = severity
p = RCSR(params)
p.run()

```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)

ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-p.severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)
    
G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 0.5,c = 'k')


```


## Things are slow to converge near the stability boundary

```{python}
run '/Users/octavia/Dropbox/fire/src_v1/startup.py'
```

```{python}
update = {"alpha" : 0.02,                
          "RI" : 20,
          "ti" : 1000,
          "tmax" : 10000,
          "dt_p" : .01
         }
params.update(update)
p = RCSR(update)
print_limits(p)
```

_Move closer to the severity threshold and reinitialize_

```{python}
update["severity"] = p.max_severity_u() - 0.02
p = RCSR(update)
diff = diff_from_default(update)
p.run()
```

```{python}
canopy_plot(p, nfire=10)
```

```{python}
fig, ax = plt.subplots(1, figsize = (5,4))
p.record["G_u_error"] = (p.mean_G_u()- p.record.G_u_mean)/p.mean_G_u()*100

ax.plot(p.record.year[10:], p.record.G_u_error[10:])
ax.set_ylabel("$G_u$ percent error")
ax.set_xlabel("year")
# # ???????????
```

## Upper canopy stability is sensitive to $\beta$

```{python}
fig, axes = plt.subplots(1,2, figsize = (14, 4))
betas = np.arange(0,1,0.01)
Ss = [0.2, 0.5, 0.7]
ax = axes[0]
for S in Ss:
    r_up = p.r_u*S**betas
    min_RI = -1./r_up*np.log(1-p.severity)

    ax.plot(betas, min_RI, label = S)
    ax.fill_between(betas, min_RI, np.max(min_RI), alpha = 0.1)

ax.set_xlabel(r"$\beta$")
ax.set_title("Minimum $RI$ to sustain $G_u$")
ax.set_ylabel(r"$RI$")

ax.legend(title = "$S$")


ax = axes[1]

S = np.arange(0.2, 1,0.01)
betas = [0.25, 0.5, 0.75]

for beta in betas:
    r_up = p.r_u*S**beta
    min_RI = -1./r_up*np.log(1-p.severity)
    ax.plot(S, min_RI, label = beta)

    plt.fill_between(S, min_RI, np.max(min_RI), alpha = 0.1)

ax.set_xlabel(r"$S$")
ax.set_ylabel("$RI$")
ax.set_title("Minimum $RI$ to sustain $G_u$")
ax.legend(title = r"$\beta$")    
fig.savefig(figdir + '/stability_min_RI.png', format='png', dpi=300, bbox_inches = "tight")



```

## Lower canopy stability is sensitive to $\beta$

```{python}
def print_dict(d):
    # attrs = vars(self)
    d =  ',  '.join("$%s$ = %s" % item for 
        item in d.items()) 
    return d
```

```{python}
def G_l_stability_v_beta(p, update,  betas, ax):
    """
    Plot the stability of the lower canopy as a function of beta
    """
    max_RI = max_RI_l(p.r_l, p.r_u, p.k_u, p.S, betas, p.alpha, p.RI, p.severity)
    max_RI[(p.alpha *p.k_u - p.r_l*p.S**betas) < 0.0] = np.nan
    max_RI[max_RI > 100] = np.nan
    min_RI = min_RI_l(p.r_l, p.S, betas, p.severity)

    ax.plot(betas, max_RI, label = "max $RI$ ")
    ax.plot(betas, min_RI, label = "min $RI$ ")
    ax.fill_between(betas, min_RI, max_RI, alpha = 0.1)

    ax.legend()
    ax.set_title("Lower canopy stability; " + print_dict(update))
    ax.set_xlabel(r"$\beta$")
    ax.set_ylabel(r"$RI$")

    
    return ax
```

```{python}
fig, axes = plt.subplots(1,2, sharey = True, figsize = (14, 4))

params = all_params()

betas = np.arange(0.3, 1, 0.01)
ax = axes[0]
update = {"S" : 0.2, "severity" : 0.1}
params.update(update)
p = RCSR(params)

ax = G_l_stability_v_beta(p, update, betas, ax)

ax = axes[1]
update = {"S" : 0.5, "severity" : 0.1}
params.update(update)
p = RCSR(params)

ax = G_l_stability_v_beta(p, update, betas, ax)

fig.savefig(figdir + '/G_l_stability_v_beta.png', format='png',
            dpi=300, bbox_inches = "tight")

```

## Test out intuition here

```{python}
update = {"S" : 0.5, "beta"  : 1, "RI" : 20}
params.update(update)
p = RCSR(update)

p.run()
```

## Lower canopy stability is sensitive to $\alpha$

```{python}
def G_l_stability_v_alpha(p, update,  alphas, ax):
    """
    Plot the stability of the lower canopy as a function of alpha
    """
    max_RI = max_RI_l(p.r_l, p.r_u, p.k_u, p.S, p.beta, alphas, p.RI, p.severity)
    max_RI[(alphas *p.k_u - p.r_l*p.S**p.beta) < 0.0] = np.nan
    max_RI[max_RI > 100] = np.nan
    min_RI = min_RI_l(p.r_l, p.S, p.beta, p.severity)
    
    ax.plot(alphas, max_RI, label = print_dict(update))
    ax.fill_between(alphas, min_RI, max_RI, alpha = 0.1)

    ax.legend()
    ax.set_title("Lower canopy stability")
    ax.set_xlabel(r"$\alpha$")
    ax.set_ylabel(r"$RI$")

    
    return ax
```

```{python}
fig, axes = plt.subplots(1,2, sharey = True, figsize = (14, 4))

alphas = np.arange(0, 0.2, 0.001)
params = all_params()
params.update({"S" : 0.2})
ax = axes[0]
severities = [0.1, 0.5, 0.9]
for severity in severities:
    update = {"severity" : severity}
    params.update(update)
    p = RCSR(params)
    ax = G_l_stability_v_alpha(p, update, alphas, ax)

ax = axes[1]
betas = [0.1, 0.5, 0.9]
for beta in betas:
    update = {"beta" : beta}
    params.update(update)
    p = RCSR(params)
    ax = G_l_stability_v_alpha(p, update, alphas, ax)

fig.savefig(figdir + '/G_l_stability_v_alpha.png', format='png',
            dpi=300, bbox_inches = "tight")


```

## Lower canopy stability is sensitive to $r_l$

```{python}

fig, axes = plt.subplots(1, sharey = True, figsize = (7, 3.5))

r_l = np.arange(0.25, 1.5, 0.01)

max_RI = max_RI_l(r_l, p.r_u, p.k_u, p.S, beta, p.alpha, p.RI, p.severity)
max_RI[(alpha *p.k_u - r_l*p.S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, p.S, beta, p.severity)

plt.plot(r_l/p.r_u, max_RI, label = "max RI ")
plt.plot(r_l/p.r_u, min_RI, label = "min RI ")
plt.fill_between(r_l/p.r_u, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$r_l / r_u$")
plt.ylabel(r"$RI$")

plt.title("$RI$ bounds for lower canopy stability")

fig.savefig(figdir + '/G_l_stability_v_rl.png', format='png',
            dpi=300, bbox_inches = "tight")


```

### There is a range of return intervals where G_l persists, even though its equilbrium value would be zero

```{python}
params = all_params()
p = RCSR(params)
RIs = np.arange(0, 20, 0.01)

# mean G_u
G_u_mean = mean_G_u( p.r_u, p.k_u, p.S, p.beta, RIs, p.severity)
# mean G_l
G_l_mean = mean_G_l(p.r_l, p.r_u, p.k_l, p.k_u, p.S, p.beta, p.alpha, RIs, p.severity)

#  G_l_eq (in equilibrium with G_u pre-fire)
G_l_eq = G_l_equil(p.r_l, p.r_u, p.k_l,  p.k_u, p.S, p.beta, p.alpha, RIs, p.severity)
G_l_eq[G_u_mean == 0] = np.nan

fig, ax = plt.subplots(1, sharey = True, figsize = (7, 3.5))

RI_u_min = min_RI_u(p.r_u, p.S, p.beta, p.severity)

ax.plot(RIs, G_l_eq/p.k_l, label = "`steady-state' $G_l$")
ax.plot(RIs, G_l_mean/p.k_l, '--', label = "$\hat G_l/k_l$")
ax.plot(RIs, G_u_mean/p.k_u, label = "$\hat G_u/k_u$")

ax.legend(loc='center left', bbox_to_anchor=(0.99, 0.5))
plt.axvline(RI_u_min, c = 'k', lw = 1, ls = '--')
ax.set_xlabel("RIs")
ax.set_ylabel("normalized mean biomass")
```

## Recovery time for the upper biomass to return to $\gamma k_u$

```{python}
params = all_params()
update = {
          "alpha" : 0.02,
          "beta" : 1,          
          "RI" : 29,
          "severity" : 0.5,
         }
params.update(update)


p = RCSR(update)
```

<!-- #region -->
$$ t = \frac{1}{r} \log\bigg( \frac{\gamma  \phi_S}{(1-\gamma)(1 - \phi_S - e^ {-r\omega})}\bigg)$$

where $\xi $ is the return interval.


Note that the denominator, $1 - \phi_S - e^{-r\omega}$ must be greater than zero.
This is the same as the 'canopy collapse' threshold for $G_u > 0$

Near the threshold, the biomass takes longer to reach the carrying capacity.
<!-- #endregion -->

```{python}
G_u_min = p.G_u_postfire()
r_up = p.r_u*p.S**p.beta
gamma = np.arange(.9, 1., .001)

plt.plot(1/r_up*np.log(gamma/(1-gamma)*(p.k_u - G_u_min)/G_u_min), gamma)
plt.plot(1/r_up*np.log(gamma/(1-gamma)*p.severity/(1-p.severity - np.exp(-r_up*p.RI))), gamma)
plt.xlabel("time (years)")
plt.ylabel(r"$\gamma$");


```

For more frequent, higher intensity fires, $G_u$ is not reaching $\gamma k$, resulting in nans.

Frequency only affects the results for higher frequency fires, where it is influencing $G_{u,o}$



```{python}

def equil_time(r, gamma, severity,  freq):
    
    return 1/r*np.log(gamma/(1-gamma)*severity/(1-severity - np.exp(-r*freq)))

freqs = np.arange(10, 100)
severities = np.arange(0.3, 1, .01)
freqs, severities = np.meshgrid(freqs, severities)
plt.contourf( freqs, severities, equil_time(r_up, .8, severities,  freqs),20, cmap = "Blues")
plt.colorbar()

plt.xlabel("RI")
plt.ylabel(r"severity");
```

## How close to $k_u$ does $G_u$ get?

```{python}
def fix_G_u_max(r, S, beta, RI, gamma ):
    """
    Given return time RI and plant parameters,
    finds the severity for which G_u_max = k_u*gamma
    """
    
    r_up = r_u*S**beta
    C =  1./gamma -1
    phi_S = C*(1- np.exp(-r_u*RI))/(C + np.exp(-r_u*RI))

    
    y = 1- phi_S - np.exp(-r_up*RI) # stability threshold
 
    
    if np.size(y) == 1:
        if y < 0:
            phi_S = np.nan
            
    else:
        phi_S[y<0] = np.nan
    
    return phi_S
        

RIs = np.arange(1,30)

r_u = 0.25;
S = 0.21;
beta = 0.5;
gamma = 0.2
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.9
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.99
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)

gamma = 0.999
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)


plt.plot(RIs,RIs*0, "k", lw = .1)
plt.legend()


```

## Now we know we can parallelize it... -  need to change python virtual env

```{python}
import time
from multiprocessing import Pool

updates = [{"dt_p" : np.round(s, 5)} for  s in  [0.1, 1]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 1000, 
              "tmax" : 1000,
              "RI" : 29,
              "severity" : 0.7,
              "dt" : 0.01,
              "dt_p" : 1,
              "severity_type" : "random",
              "ignition_type" : "random",          
              "sigma_phi" : 0.01,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes


result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

p = result[0]

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}
for p in result:
    to = - int(5*p.RI/p.dt_p)
    plt.plot(p.t_p[to:], p.G_u_list[to:], '-', label = np.round(p.mean_G_u(), 3))
plt.legend()
```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 1,c = 'k')
    

```

```{python}
import time
from multiprocessing import Pool

def f(x):
    return x*x

updates = [{"dt" : np.round(s, 5)} for  s in  [0.001, 0.01]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 0, 
              "tmax" : 2000,
              "ignition_freq" : 29,
              "severity" : 0.7815,
              "dt" : 0.01,
              "dt_p" : 0.1,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes

result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

```

```{python}
for p in result:
    plt.plot(p.G_u_list, label = p.dt)
plt.legend()
    
```

## Plot the analytical solution

```{python}

# (1) plot the analytical solution after any given fire 
# (2) check the analytical predictions of minimum and maximum G_u
# (3) check the approximation of minimum G_l.  Move on to analytic expression for G_l later

RI = 20
severity = 0.5
update = {
          "alpha" : 0.1,
          "r_l" : 2,
          "beta" : 0,
          "ti" : 2000, 
          "RI" : RI,
          "tmax" : 3*RI,
          "severity" : severity,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }
                
p = RCSR(update)
p.run()

fig, ax = plt.subplots(1, figsize = (14,4) )


ax.plot(p.t_p, p.G_u_list, '-', label ="upper canopy")        
ax.plot(p.t_p, p.G_l_list, label = "lower canopy")       
plot_G_l_a(p,ax)   
plot_G_u_a(p,ax)   
ax.legend()
ax.set_ylabel("biomass")    
plot_fire_events(p, ax)

```

```{python}
import numpy as np
a = np.arange(1,17)
```

```{python}
a.reshape(4, 4)
```

```{python}
## Schematic comparison of ICB and SLC

RIs = np.arange(0, 100, .1)
G_us = mean_G_u(p.r_u, p.k_u, p.S, p.beta, RIs, p.severity)
line = plt.plot(  RIs,G_us, label = "IC")

RI_i = 80; 
RI_f = 20;
G_u_i = (mean_G_u(p.r_u, p.k_u, p.S, p.beta, RI_i, p.severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.75, "o", c= line[0].get_color(), ms = 10)


##. Update SLC soil moisture
p.S = 0.25

RIs = np.arange(0, 100, .1)
G_us = mean_G_u(p.r_u, p.k_u, p.S, p.beta, RIs, p.severity)
line = plt.plot(  RIs,G_us, label = "SL")

RI_i = 80; 
RI_f = 40;
G_u_i = (mean_G_u(p.r_u, p.k_u, p.S, p.beta, RI_i, p.severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.95, "o", c= line[0].get_color(), ms = 10)


plt.legend(loc = "lower right")
plt.xlabel("RI")
plt.ylabel("$G_u$")
```

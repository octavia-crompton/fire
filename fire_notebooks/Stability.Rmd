---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: fire3
    language: python
    name: fire3
---

```{python}
# %autosave 0
```

```{python}

# import sys

# sys.path.append("/Users/octavia/Dropbox/fire/src_v1" )

# mymodules = ['plot_config', "fire_model", "fire_utility", "filepaths",
#              "fire_plot", "fire_analytic" ]

# for mod in mymodules:
#     if mod in sys.modules:
#         del sys.modules[mod]


# from plot_config import *
# from fire_model import *
# from fire_analytic import *
# from fire_utility import *
# from fire_plot import *
# from filepaths import *
```

```{python}
import os
startup_file = "/Users/octavia/Dropbox/fire/src_v1/startup.py"
```

```{python}
run "/Users/octavia/Dropbox/fire/src_v1/startup.py"
```

###  Maximum severity / minimm return interval to sustain upper canopy biomass

```{python}
params =  {
    "alpha" : 0.04,
    "beta" : 0.5,
    "k_u" : 20.,
    "k_l" : 5.,    
    "r_u" : 0.25,
    "r_l" : 1.5,                    
    "S" : 0.5,
    "dt" : 0.01,
    "dt_p" : 0.1,            
    "seed" : 0,
    "ti" : 1000,        
    "tmax" : 3000,      
    "RI" : 20,
    "ignition_type" : "fixed",   
    "chi" : 1,                           
    "severity_type" : "fixed",
    "severity" : 0.7,
    "std_severity" : 0.1,
    "r" : 0.5, 
    "a" : 0.01,
    "b" : 0.99
} 
p = RCSR(params)
```

```{python}

fig, ax = plt.subplots(1, figsize = (7,4) )

RIs = np.arange(0, 100, .1)
severities = max_severity_u(p.r_u*p.S**p.beta, RIs)
ax.plot(  RIs,severities )
ax.fill_between(RIs,severities, alpha = 0.1)

for gamma in [0.1, 0.5, 0.75, 0.9]:
    severities = max_severity_u((1-gamma)*p.r_u*p.S**p.beta, RIs)
    ax.plot(RIs, severities , '--', label = gamma)


ax.legend(title = "$\gamma$")
ax.set_ylabel("maximum severity")
ax.set_xlabel("Return interval (years)")
ax.set_title("Stability curve ($\hat G_u = \gamma k_u$)")
fig.savefig(figdir + '/stability.png', format='png', dpi=1000, bbox_inches = "tight")

```

## Double check the stability curve

```{python}
gamma = 0.5
p = RCSR(params)
severity = max_severity_u((1-gamma)*p.r_u*p.S**p.beta, p.RI)
params["severity"] = severity
p = RCSR(params)
p.run()

```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)

ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-p.severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)
    
G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 0.5,c = 'k')


```


## Things are slow to converge near the stability boundary

```{python}
run '/Users/octavia/Dropbox/fire/src_v1/startup.py'
```

```{python}
update = {"alpha" : 0.02,                
          "RI" : 20,
          "ti" : 1000,
          "tmax" : 10000,
          "dt_p" : .01
         }
params.update(update)
p = RCSR(update)
print_limits(p)
```

_Move closer to the severity threshold and reinitialize_

```{python}
update["severity"] = p.max_severity_u() - 0.02
p = RCSR(update)
diff = diff_from_default(update)
p.run()
```

```{python}
p.record.tail()
```

```{python}
canopy_plot(p, nfire=10)
```

```{python}
p.record.tail()
```

```{python}
fig, ax = plt.subplots(1, figsize = (5,4))
p.record["G_u_error"] = (p.mean_G_u()- p.record.G_u_mean)/p.mean_G_u()*100

ax.plot(p.record.year[10:], p.record.G_u_error[10:])
ax.set_ylabel("$G_u$ percent error")
ax.set_xlabel("year")
# # ???????????
```

## Upper canopy stability is sensitive to $\beta$

```{python}
fig, axes = plt.subplots(1,2, figsize = (14, 4))
betas = np.arange(0,1,0.01)
Ss = [0.2, 0.5, 0.7]
ax = axes[0]
for S in Ss:
    r_up = p.r_u*S**betas
    min_RI = -1./r_up*np.log(1-p.severity)

    ax.plot(betas, min_RI, label = S)
    ax.fill_between(betas, min_RI, np.max(min_RI), alpha = 0.1)

ax.set_xlabel(r"$\beta$")
ax.set_title("Minimum $RI$ for $G_u$")
ax.set_ylabel(r"$RI$")

ax.legend(title = "$S$")


ax = axes[1]

S = np.arange(0.2, 1,0.01)

betas = [0.25, 0.5, 0.75]
for beta in betas:
    r_up = p.r_u*S**beta
    min_RI = -1./r_up*np.log(1-p.severity)
    plt.plot(S, min_RI, label = beta)

    plt.fill_between(S, min_RI, np.max(min_RI), alpha = 0.1)

    
fig.savefig(figdir + '/stability_min_RI.png', format='png', dpi=1000, bbox_inches = "tight")

# # # 
# # # As betas increases, r'_u decreases, so the minimum RI to sustain biomass increases
```

```{python}

```

```{python}

# beta = 0.75
# r_up = r_u*S**beta
# min_RI = -1./r_up*np.log(1-p.severity)
# plt.plot(S, min_RI, label = r"$\beta$ = 0.75")

# plt.fill_between(S, min_RI, np.max(min_RI), alpha = 0.1)

# plt.xlabel(r"$S$")
# plt.ylabel("$RI$")
# plt.title("Minimum $RI$ for $G_u$")
# plt.legend()
```

## Lower canopy stability is sensitive to $\beta$

```{python}
set_defaults()
beta = np.arange(0.3,1,0.01)
r = r_u*S**beta

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)

plt.plot(beta, max_RI, label = "max RI ")
plt.plot(beta, min_RI, label = "min RI ")
plt.fill_between(beta, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$\beta$")
plt.ylabel(r"$RI$")
plt.title("Lower canopy stability")
```

## Lower canopy stability is sensitive to $\alpha$

```{python}
set_defaults()

alpha = np.arange(0,0.3, 0.01)

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)
min_RI = np.ones_like(alpha)*min_RI
plt.plot(alpha, max_RI, label = "max RI ")
plt.plot(alpha, min_RI, label = "min RI ")
plt.fill_between(alpha, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$\alpha$")
plt.ylabel(r"$RI$")
plt.title("$RI$ bounds for lower canopy stability")
# With greater competition, more frequent fires are needed to sustain G_l
```

## Lower canopy stability is sensitive to $r_l$

```{python}
set_defaults()
alpha = 0.06
r_l = np.arange(0.25, 1.5, 0.01)

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)

plt.plot(r_l/r_u, max_RI, label = "max RI ")
plt.plot(r_l/r_u, min_RI, label = "min RI ")
plt.fill_between(r_l/r_u, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$r_l / r_u$")
plt.ylabel(r"$RI$")

plt.title("$RI$ bounds for lower canopy stability")
# As lower canopy growth rate decreases, so does the range of values for which G_l > 0. 
```

## There is a range where G_l persists, even though it is not in equilbrium with $G_u$ before the fire

```{python}
set_defaults()
RI = np.arange(0, 20, 0.01)

# mean G_u
G_u_mean = mean_G_u( r_u, k_u, S, beta, RI, severity)

#  G_l_eq (equilibrium with G_u pre-fire)
G_l_eq = G_l_equil(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity)
G_l_mean = mean_G_l(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity)

#  G_l_eq (equilibrium with G_l post-fire)
G_l_max_logistic = G_prefire(r_l, k_l, RI, severity)
G_l_eq[G_u_mean == 0] = G_l_max_logistic[G_u_mean == 0]

RI_u_min = min_RI_u(r_u, S, beta, severity)

# plt.plot(RI, G_l_eq/k_l, label = "equil G_l")
plt.plot(RI, G_l_mean/k_l, '--', label = "mean $G_l/k_l$")
plt.plot(RI, G_u_mean/k_u, label = "mean $G_u/r_u$")

plt.legend()
plt.axvline(RI_u_min, c = 'k', lw = 1, ls = '--')
plt.xlabel("RI")
```

```{python}
p = RCSR()
set_defaults()
update = {"soil_feedback" : "C",
          "r_l" : r_l,
          "r_u" : r_u,
          "k_l" : k_l,
          "k_u" : k_u,
          "alpha" : alpha,
          "beta" : 0.,
          "G_u" : k_u/10.,
          "G_l" : k_l/10., 
          "ti" : 1000, 
          "tmax" : 100,
          "RI" : 15,
          "severity" : 0.5,
          "dt" : 0.01
         }


p = RCSR(update)
p.run()


print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))

fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 1,c = 'k')

```

## Recovery time for the upper biomass to return to $\gamma k_u$

```{python}

update = {"soil_feedback" : "C",
          "alpha" : 0.02,
          "beta" : 1,
          "ti" : 0, 
          "tmax" : 2000,
          "RI" : 29,
          "severity" : 0.5,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }

p = RCSR(update)
```

<!-- #region -->
$$ t = \frac{1}{r} \log\bigg( \frac{\gamma ( \phi_S)}{(1-\gamma)(1 - \phi_S - e^ {-r\omega})}\bigg)$$

where $\xi $ is the return interval.


Note that the denominator, $1 - \phi_S - e^{-r\omega}$ must be greater than zero.
This is the same as the 'canopy collapse' threshold for $G_u > 0$

Near the threshold, the biomass takes longer to reach the carrying capacity.
<!-- #endregion -->

```{python}
G_u_min = p.G_u_postfire()
r_up = p.r_u*p.S**p.beta
gamma = np.arange(.9, 1., .001)

plt.plot(1/r_up*np.log(gamma/(1-gamma)*(p.k_u - G_u_min)/G_u_min), gamma)
plt.plot(1/r_up*np.log(gamma/(1-gamma)*p.severity/(1-p.severity - np.exp(-r_up*p.RI))), gamma)
plt.xlabel("time (years)")
plt.ylabel(r"$\gamma$");


```

For more frequent, higher intensity fires, $G_u$ is not reaching $\gamma k$, resulting in nans.

Frequency only affects the results for higher frequency fires, where it is influencing $G_{u,o}$



```{python}

def equil_time(r, gamma, severity,  freq):
    
    return 1/r*np.log(gamma/(1-gamma)*severity/(1-severity - np.exp(-r*freq)))

freqs = np.arange(10, 100)
severities = np.arange(0.3, 1, .01)
freqs, severities = np.meshgrid(freqs, severities)
plt.contourf( freqs, severities, equil_time(r_up, .8, severities,  freqs),20, cmap = "Blues")
plt.colorbar()

plt.xlabel("RI")
plt.ylabel(r"severity");
```

## How close to $k_u$ does $G_u$ get?

```{python}
def fix_G_u_max(r, S, beta, RI, gamma ):
    """
    Given return time RI and plant parameters,
    finds the severity for which G_u_max = k_u*gamma
    """
    
    r_up = r_u*S**beta
    C =  1./gamma -1
    phi_S = C*(1- np.exp(-r_u*RI))/(C + np.exp(-r_u*RI))

    
    y = 1- phi_S - np.exp(-r_up*RI) # stability threshold
 
    
    if np.size(y) == 1:
        if y < 0:
            phi_S = np.nan
            
    else:
        phi_S[y<0] = np.nan
    
    return phi_S
        

RIs = np.arange(1,30)

r_u = 0.25;
S = 0.21;
beta = 0.5;
gamma = 0.2
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.9
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.99
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)

gamma = 0.999
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)


plt.plot(RIs,RIs*0, "k", lw = .1)
plt.legend()


```

## Now we know we can parallelize it... -  need to change python virtual env

```{python}
import time
from multiprocessing import Pool

updates = [{"dt_p" : np.round(s, 5)} for  s in  [0.1, 1]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 1000, 
              "tmax" : 1000,
              "RI" : 29,
              "severity" : 0.7,
              "dt" : 0.01,
              "dt_p" : 1,
              "severity_type" : "random",
              "ignition_type" : "random",          
              "sigma_phi" : 0.01,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes


result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

p = result[0]

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}
for p in result:
    to = - int(5*p.RI/p.dt_p)
    plt.plot(p.t_p[to:], p.G_u_list[to:], '-', label = np.round(p.mean_G_u(), 3))
plt.legend()
```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 1,c = 'k')
    

```

```{python}
import time
from multiprocessing import Pool

def f(x):
    return x*x

updates = [{"dt" : np.round(s, 5)} for  s in  [0.001, 0.01]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 0, 
              "tmax" : 2000,
              "ignition_freq" : 29,
              "severity" : 0.7815,
              "dt" : 0.01,
              "dt_p" : 0.1,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes

result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

```

```{python}
for p in result:
    plt.plot(p.G_u_list, label = p.dt)
plt.legend()
    
```

## Plot the analytical solution

```{python}

# (1) plot the analytical solution after any given fire 
# (2) check the analytical predictions of minimum and maximum G_u
# (3) check the approximation of minimum G_l.  Move on to analytic expression for G_l later

RI = 20
severity = 0.5
update = {
          "alpha" : 0.1,
          "r_l" : 2,
          "beta" : 0,
          "ti" : 2000, 
          "RI" : RI,
          "tmax" : 3*RI,
          "severity" : severity,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }
                
p = RCSR(update)
p.run()

fig, ax = plt.subplots(1, figsize = (14,4) )


ax.plot(p.t_p, p.G_u_list, '-', label ="upper canopy")        
ax.plot(p.t_p, p.G_l_list, label = "lower canopy")       
plot_G_l_a(p,ax)   
plot_G_u_a(p,ax)   
ax.legend()
ax.set_ylabel("biomass")    
plot_fire_events(p, ax)

```

```{python}
import numpy as np
a = np.arange(1,17)
```

```{python}
a.reshape(4, 4)
```

```{python}
## Schematic comparison of ICB and SLC

RIs = np.arange(0, 100, .1)
G_us = mean_G_u(p.r_u, p.k_u, p.S, p.beta, RIs, p.severity)
line = plt.plot(  RIs,G_us, label = "IC")

RI_i = 80; 
RI_f = 20;
G_u_i = (mean_G_u(p.r_u, p.k_u, p.S, p.beta, RI_i, p.severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.75, "o", c= line[0].get_color(), ms = 10)


##. Update SLC soil moisture
p.S = 0.25

RIs = np.arange(0, 100, .1)
G_us = mean_G_u(p.r_u, p.k_u, p.S, p.beta, RIs, p.severity)
line = plt.plot(  RIs,G_us, label = "SL")

RI_i = 80; 
RI_f = 40;
G_u_i = (mean_G_u(p.r_u, p.k_u, p.S, p.beta, RI_i, p.severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.95, "o", c= line[0].get_color(), ms = 10)


plt.legend(loc = "lower right")
plt.xlabel("RI")
plt.ylabel("$G_u$")
```

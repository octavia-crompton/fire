---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: fire3
    language: python
    name: fire3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import sys
import time
import itertools
import multiprocessing as mp
import copy
import math
import scipy

sys.path.append("/Users/octavia/Dropbox/fire/src_v1" )

mymodules = ['plot_config', "fire_model", "fire_plot", "fire_analytic" ]

for mod in mymodules:
    if mod in sys.modules:
        del sys.modules[mod]

from plot_config import *
from fire_model import *
from fire_analytic import *
from fire_plot import *
```

```{python}
# We can predict the max severity and min return interval to sustain biomass in the upper canopy

p = RCSR()
update = {"r_u" :0.15,
          "r_l" : 0.45,
          "k_u" : 20,
          "k_l" : 5,
          "S" : 0.5,
          "beta" : 1,
          "alpha" : 0.01,
          "G_lo" : p.k_l/100., 
          "G_uo" : p.k_u/100.,           
          "soil_feedback" : "C",          
          "ti" : 0, 
          "tmax" : 100,
          "RI" : 100,
          "severity" : 0.5,
          "dt" : 0.01,
          "dt_p" : 0.1
         }
p = RCSR(update)

p.run()

RIs = np.arange(0, 100, .1)
severities = p.max_severity(p.r_u*p.S**p.beta, RIs)
plt.plot(  RIs,severities )
plt.fill_between(RIs,severities, alpha = 0.1)

for gamma in [0.1, 0.5, 0.75, 0.9]:
    severities = p.max_severity((1-gamma)*p.r_u*p.S**p.beta, RIs)
    plt.plot(RIs, severities , '--', label = gamma)


plt.legend(title = "$\gamma$")
plt.ylabel("maximum severity")
plt.xlabel("Return interval (years)")
plt.title("Stability curve ($\hat G_u = \gamma k_u$)")
# Take aways: 
# once you get to a 20 year return, you can have very high severity fires.
# stability boundary does not depend on the carrying capacity - only the growth rate.
# (i.e. slower growing forests can't burn as often.)
```

## Schematic comparison of IC and SL

```{python}
r_u = 0.15
r_l = 0.45
k_u = 20
k_l = 5
beta = 0.5 

severity = 0.5
S = 0.5
RIs = np.arange(0, 100, .1)
G_us = mean_G_u(r_u, k_u, S, beta, RIs, severity)
line = plt.plot(  RIs,G_us, label = "IC")

RI_i = 80; 
RI_f = 20;
G_u_i = (mean_G_u(r_u, k_u, S, beta, RI_i, severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.75, "o", c= line[0].get_color(), ms = 10)


S = 0.25
RIs = np.arange(0, 100, .1)
G_us = mean_G_u(r_u, k_u, S, beta, RIs, severity)
line = plt.plot(  RIs,G_us, label = "SL")

RI_i = 80; 
RI_f = 40;
G_u_i = (mean_G_u(r_u, k_u, S, beta, RI_i, severity))
plt.plot(RI_i, G_u_i, "o",  c= line[0].get_color(), ms = 10)
plt.plot(RI_f, G_u_i*0.95, "o", c= line[0].get_color(), ms = 10)


plt.legend(loc = "lower right")
plt.xlabel("RI")
plt.ylabel("$G_u$")
```

## Stability of the lower canopy

```{python}
S = 0.5
beta = 0.5
k_u = 20
r_l = 0.45
max_alpha = r_l*S**beta/k_u

print (max_alpha)
```

## $G_l$ along the 'stability curve'

```{python}

p = RCSR()

up = {"r_u" :0.25,
          "r_l" : 1.5,
          "k_u" : 20,
          "k_l" : 5,
          "S" : 0.21,
          "beta" : 0.1,
          "alpha" : 0.03,
          "soil_feedback" : "C",                  
          "G_u" : p.k_u/10.,
          "G_l" : p.k_l/10., 
          "ti" : 1000, 
          "tmax" : 1000,
          "RI" : 10,
          "dt" : 0.01,
          "dt_p" : 0.1,

         }
gamma = 0.5
up["severity"] = 1 - np.exp(-(1-gamma)*up["r_u"]*up["S"]**up["beta"]*up["RI"])

p = RCSR(up)

p.run()

```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)

ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-p.severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)
    
G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 0.5,c = 'k')


```

## Things are slow to converge near the stability boundary

```{python}

p = RCSR()
update = {"soil_feedback" : "C",
          "alpha" : 0.02,
          "beta" : 1,
          "G_u" : p.k_u/10.,
          "G_l" : p.k_l/10., 
          "ti" : 1000, 
          "tmax" : 3000,
          "RI" : 29,
          "severity" : 0.7818,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }


p = RCSR(update)
p.run()

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}

p.record["error"] = (p.mean_G_u()- p.record.G_u_mean)/p.mean_G_u()*100
p.record.tail()
plt.plot(p.record.year, p.record["error"])
plt.ylabel("error")
plt.xlabel("year")
```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = - int(5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("biomass")
ax.legend()


G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-p.severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

```

## Upper canopy stability is sensitive to $\beta$

```{python}
def set_defaults():
    r_l = 1.5
    r_u = 0.25
    k_u = 20
    k_l = 5
    RI = 20
    S = .21
    alpha = 0.06
    beta = 0.5
    severity = 0.5
    globals().update(locals())
```

```{python}
set_defaults()

beta = np.arange(0,1,0.01)
r_up = r_u*S**beta
min_RI = -1./r_up*np.log(1-severity)

plt.plot(beta, min_RI)
plt.fill_between(beta, min_RI, np.max(min_RI), alpha = 0.1)

plt.xlabel(r"$\beta$")
plt.ylabel("$RI$")
plt.title("Minimum $RI$ for $G_u$")

# Increasing beta is like decreasing the growth rate, for fixed soil moisture.
# As beta increases, r'_u decreases, so the minimum RI to sustain biomass increases
```

```{python}
set_defaults()

S = np.arange(0.01, 0.3,0.01)

beta = 0.5
r_up = r_u*S**beta
min_RI = -1./r_up*np.log(1-severity)
plt.plot(S, min_RI, label = r"$\beta$ = 0.5")

plt.fill_between(S, min_RI, np.max(min_RI), alpha = 0.1)

beta = 0.75
r_up = r_u*S**beta
min_RI = -1./r_up*np.log(1-severity)
plt.plot(S, min_RI, label = r"$\beta$ = 0.75")

plt.fill_between(S, min_RI, np.max(min_RI), alpha = 0.1)

plt.xlabel(r"$S$")
plt.ylabel("$RI$")
plt.title("Minimum $RI$ for $G_u$")
plt.legend()
```

## Lower canopy stability is sensitive to $\beta$

```{python}
set_defaults()
beta = np.arange(0.3,1,0.01)
r = r_u*S**beta

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)

plt.plot(beta, max_RI, label = "max RI ")
plt.plot(beta, min_RI, label = "min RI ")
plt.fill_between(beta, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$\beta$")
plt.ylabel(r"$RI$")
plt.title("Lower canopy stability")
```

## Lower canopy stability is sensitive to $\alpha$

```{python}
set_defaults()

alpha = np.arange(0,0.3, 0.01)

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)
min_RI = np.ones_like(alpha)*min_RI
plt.plot(alpha, max_RI, label = "max RI ")
plt.plot(alpha, min_RI, label = "min RI ")
plt.fill_between(alpha, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$\alpha$")
plt.ylabel(r"$RI$")
plt.title("$RI$ bounds for lower canopy stability")
# With greater competition, more frequent fires are needed to sustain G_l
```

## Lower canopy stability is sensitive to $r_l$

```{python}
set_defaults()
alpha = 0.06
r_l = np.arange(0.25, 1.5, 0.01)

max_RI = max_RI_l(r_l, r_u, k_u, S, beta, alpha, RI, severity)
max_RI[(alpha *k_u - r_l*S**beta) < 0.0] = np.nan

min_RI = min_RI_l(r_l, S, beta, severity)

plt.plot(r_l/r_u, max_RI, label = "max RI ")
plt.plot(r_l/r_u, min_RI, label = "min RI ")
plt.fill_between(r_l/r_u, min_RI, max_RI, alpha = 0.1)

plt.legend()
plt.xlabel(r"$r_l / r_u$")
plt.ylabel(r"$RI$")

plt.title("$RI$ bounds for lower canopy stability")
# As lower canopy growth rate decreases, so does the range of values for which G_l > 0. 
```

## There is a range where G_l persists, even though it is not in equilbrium with $G_u$ before the fire

```{python}
set_defaults()
RI = np.arange(0, 20, 0.01)

# mean G_u
G_u_mean = mean_G_u( r_u, k_u, S, beta, RI, severity)

#  G_l_eq (equilibrium with G_u pre-fire)
G_l_eq = G_l_equil(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity)
G_l_mean = mean_G_l(r_l, r_u, k_l,  k_u, S, beta, alpha, RI, severity)

#  G_l_eq (equilibrium with G_l post-fire)
G_l_max_logistic = G_prefire(r_l, k_l, RI, severity)
G_l_eq[G_u_mean == 0] = G_l_max_logistic[G_u_mean == 0]

RI_u_min = min_RI_u(r_u, S, beta, severity)

# plt.plot(RI, G_l_eq/k_l, label = "equil G_l")
plt.plot(RI, G_l_mean/k_l, '--', label = "mean $G_l/k_l$")
plt.plot(RI, G_u_mean/k_u, label = "mean $G_u/r_u$")

plt.legend()
plt.axvline(RI_u_min, c = 'k', lw = 1, ls = '--')
plt.xlabel("RI")
```

```{python}
p = RCSR()
set_defaults()
update = {"soil_feedback" : "C",
          "r_l" : r_l,
          "r_u" : r_u,
          "k_l" : k_l,
          "k_u" : k_u,
          "alpha" : alpha,
          "beta" : 0.,
          "G_u" : k_u/10.,
          "G_l" : k_l/10., 
          "ti" : 1000, 
          "tmax" : 100,
          "RI" : 15,
          "severity" : 0.5,
          "dt" : 0.01
         }


p = RCSR(update)
p.run()


print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))

fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 1,c = 'k')

```

## Recovery time for the upper biomass to return to $\gamma k_u$

```{python}

update = {"soil_feedback" : "C",
          "alpha" : 0.02,
          "beta" : 1,
          "ti" : 0, 
          "tmax" : 2000,
          "RI" : 29,
          "severity" : 0.5,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }

p = RCSR(update)
```

<!-- #region -->
$$ t = \frac{1}{r} \log\bigg( \frac{\gamma ( \phi_S)}{(1-\gamma)(1 - \phi_S - e^ {-r\omega})}\bigg)$$

where $\xi $ is the return interval.


Note that the denominator, $1 - \phi_S - e^{-r\omega}$ must be greater than zero.
This is the same as the 'canopy collapse' threshold for $G_u > 0$

Near the threshold, the biomass takes longer to reach the carrying capacity.
<!-- #endregion -->

```{python}
G_u_min = p.G_u_postfire()
r_up = p.r_u*p.S**p.beta
gamma = np.arange(.9, 1., .001)

plt.plot(1/r_up*np.log(gamma/(1-gamma)*(p.k_u - G_u_min)/G_u_min), gamma)
plt.plot(1/r_up*np.log(gamma/(1-gamma)*p.severity/(1-p.severity - np.exp(-r_up*p.RI))), gamma)
plt.xlabel("time (years)")
plt.ylabel(r"$\gamma$");


```

For more frequent, higher intensity fires, $G_u$ is not reaching $\gamma k$, resulting in nans.

Frequency only affects the results for higher frequency fires, where it is influencing $G_{u,o}$



```{python}

def equil_time(r, gamma, severity,  freq):
    
    return 1/r*np.log(gamma/(1-gamma)*severity/(1-severity - np.exp(-r*freq)))

freqs = np.arange(10, 100)
severities = np.arange(0.3, 1, .01)
freqs, severities = np.meshgrid(freqs, severities)
plt.contourf( freqs, severities, equil_time(r_up, .8, severities,  freqs),20, cmap = "Blues")
plt.colorbar()

plt.xlabel("RI")
plt.ylabel(r"severity");
```

## How close to $k_u$ does $G_u$ get?

```{python}
def fix_G_u_max(r, S, beta, RI, gamma ):
    """
    Given return time RI and plant parameters,
    finds the severity for which G_u_max = k_u*gamma
    """
    
    r_up = r_u*S**beta
    C =  1./gamma -1
    phi_S = C*(1- np.exp(-r_u*RI))/(C + np.exp(-r_u*RI))

    
    y = 1- phi_S - np.exp(-r_up*RI) # stability threshold
 
    
    if np.size(y) == 1:
        if y < 0:
            phi_S = np.nan
            
    else:
        phi_S[y<0] = np.nan
    
    return phi_S
        

RIs = np.arange(1,30)

r_u = 0.25;
S = 0.21;
beta = 0.5;
gamma = 0.2
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.9
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)
gamma = 0.99
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)

gamma = 0.999
plt.plot(RIs,fix_G_u_max(r, S, beta, RIs, gamma ),".--", label = gamma)


plt.plot(RIs,RIs*0, "k", lw = .1)
plt.legend()


```

## Now we know we can parallelize it... -  need to change python virtual env

```{python}
import time
from multiprocessing import Pool

updates = [{"dt_p" : np.round(s, 5)} for  s in  [0.1, 1]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 1000, 
              "tmax" : 1000,
              "RI" : 29,
              "severity" : 0.7,
              "dt" : 0.01,
              "dt_p" : 1,
              "severity_type" : "random",
              "ignition_type" : "random",          
              "sigma_phi" : 0.01,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes


result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

p = result[0]

print ("The minimum return interval with severity = {0} is {1:.2f} years".format(p.severity,p.min_RI_u()))
print ("The maximum severity with RI = {0} years is {1:.4f}".format(p.RI, p.max_severity_u()))
```

```{python}
for p in result:
    to = - int(5*p.RI/p.dt_p)
    plt.plot(p.t_p[to:], p.G_u_list[to:], '-', label = np.round(p.mean_G_u(), 3))
plt.legend()
```

```{python}
fig, ax = plt.subplots(1, figsize = (14,4) )

to = int(-5*p.RI/p.dt_p)
ax.plot(p.t_p[to:], p.G_u_list[to:], '-', label ="upper canopy")        
ax.plot(p.t_p[to:], p.G_l_list[to:], label = "lower canopy")       
ax.set_ylabel("Biomass")
ax.legend()

severity = update["severity"]

G_u_min_a = p.G_u_postfire()
G_u_max_a = G_u_min_a/(1-severity)
if G_u_min_a>0:
    plt.axhline(G_u_min_a, ls = "--", lw = 1)
    plt.axhline(G_u_max_a, ls = "--", lw = 1)

G_l_postfire = p.G_l_postfire()
if G_l_postfire>0:
    plt.axhline(p.G_l_postfire(),ls =  '--', lw = 1,c = 'k')
    

```

```{python}
import time
from multiprocessing import Pool

def f(x):
    return x*x

updates = [{"dt" : np.round(s, 5)} for  s in  [0.001, 0.01]]
        
def f(update):
    
    p = RCSR()
    
    param = {"soil_feedback" : "C",
              "alpha" : 0.02,
              "beta" : 1,
              "ti" : 0, 
              "tmax" : 2000,
              "ignition_freq" : 29,
              "severity" : 0.7815,
              "dt" : 0.01,
              "dt_p" : 0.1,
         }
    param.update(update)

    p = RCSR(param)
    p.run()
    return p

pool = Pool(processes=8)              # start 4 worker processes

result =  (pool.map(f, updates)  )        # prints "[0, 1, 4,..., 81]"
pool.close()

```

```{python}
for p in result:
    plt.plot(p.G_u_list, label = p.dt)
plt.legend()
    
```

## Plot the analytical solution

```{python}

# (1) plot the analytical solution after any given fire 
# (2) check the analytical predictions of minimum and maximum G_u
# (3) check the approximation of minimum G_l.  Move on to analytic expression for G_l later

RI = 20
severity = 0.5
update = {
          "alpha" : 0.1,
          "r_l" : 2,
          "beta" : 0,
          "ti" : 2000, 
          "RI" : RI,
          "tmax" : 3*RI,
          "severity" : severity,
          "dt" : 0.01,
          "dt_p" : 0.1,
         }
                
p = RCSR(update)
p.run()

fig, ax = plt.subplots(1, figsize = (14,4) )


ax.plot(p.t_p, p.G_u_list, '-', label ="upper canopy")        
ax.plot(p.t_p, p.G_l_list, label = "lower canopy")       
plot_G_l_a(p,ax)   
plot_G_u_a(p,ax)   
ax.legend()
ax.set_ylabel("biomass")    
plot_fire_events(p, ax)

```

```{python}
import numpy as np
a = np.arange(1,17)
```

```{python}
a.reshape(4, 4)
```

```{python}

```
